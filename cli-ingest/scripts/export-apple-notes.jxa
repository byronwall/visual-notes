// JXA script: run with `osascript -l JavaScript export-apple-notes.jxa`
// Exports Apple Notes as a single JSON array with inline HTML for each note.

function toISOString(date) {
  // JXA Date object behaves as JS Date
  return new Date(date).toISOString();
}

// Write diagnostics to stderr so stdout stays clean JSON
function logErr(msg) {
  try {
    var str = String(msg) + "\n";
    var data = $(str).dataUsingEncoding($.NSUTF8StringEncoding);
    $.NSFileHandle.fileHandleWithStandardError.writeData(data);
  } catch (_) {}
}

function nowMs() {
  return Date.now();
}

function main() {
  try {
    var tStart = nowMs();
    var app = Application("Notes");
    app.includeStandardAdditions = true;
    try {
      app.activate();
    } catch (_) {}
    logErr("[JXA] Started Notes export");

    var results = [];
    var wrote = 0;
    var skipped = 0;
    var limit = null;
    var htmlOutDir = null;
    var inlineHtml = false;
    var sinceEpochSec = null;
    var skipIndex = {};

    function getEnvString(key) {
      try {
        var env = $.NSProcessInfo.processInfo.environment;
        var obj = env.objectForKey(String(key));
        if (obj) {
          try {
            return ObjC.unwrap(obj);
          } catch (_) {
            return String(obj);
          }
        }
      } catch (_) {}
      try {
        ObjC.import("stdlib");
        var cstr = $.getenv(String(key));
        if (cstr) return ObjC.unwrap(cstr);
      } catch (_) {}
      return null;
    }

    function sanitizeFilename(title, id) {
      try {
        var base = String(title || "")
          .toLowerCase()
          .replace(/\s+/g, "-")
          .replace(/[^a-z0-9\-_.]/g, "-")
          .replace(/-+/g, "-")
          .replace(/^[-.]+|[-.]+$/g, "");
        var fallback = String(id || "").slice(0, 12) || "note";
        var trimmed = base.slice(0, 64) || fallback;
        return trimmed;
      } catch (_) {
        return "note";
      }
    }

    function sanitizeCoreDataId(id) {
      try {
        var s = String(id || "")
          .toLowerCase()
          .replace(/[^a-z0-9\-_]/g, "-")
          .replace(/-+/g, "-")
          .replace(/^[-.]+|[-.]+$/g, "");
        return s.slice(0, 64) || "id";
      } catch (_) {
        return "id";
      }
    }

    function formatTimestampUTC(dateLike) {
      try {
        var d = new Date(dateLike);
        var yyyy = String(d.getUTCFullYear());
        var mm = String(d.getUTCMonth() + 1).padStart(2, "0");
        var dd = String(d.getUTCDate()).padStart(2, "0");
        var hh = String(d.getUTCHours()).padStart(2, "0");
        var mi = String(d.getUTCMinutes()).padStart(2, "0");
        var ss = String(d.getUTCSeconds()).padStart(2, "0");
        return yyyy + mm + dd + "T" + hh + mi + ss + "Z";
      } catch (_) {
        return "unknown";
      }
    }

    function ensureDir(dirPath) {
      try {
        var fm = $.NSFileManager.defaultManager;
        var isDir = Ref();
        var nsPath = $(dirPath);
        if (!(fm.fileExistsAtPathIsDirectory(nsPath, isDir) && isDir[0])) {
          fm.createDirectoryAtPathWithIntermediateDirectoriesAttributesError(
            nsPath,
            true,
            null,
            null
          );
        }
      } catch (_) {}
    }

    function writeHtmlFile(
      dirPath,
      idx,
      title,
      id,
      createdAt,
      updatedAt,
      folder,
      htmlStr
    ) {
      try {
        var base = sanitizeFilename(title, id);
        var idPart = sanitizeCoreDataId(id);
        var ts = formatTimestampUTC(updatedAt);
        var fileName =
          String(idx) + "-" + idPart + "-" + ts + "-" + base + ".html";
        var fullPath = dirPath + "/" + fileName;
        // Build a minimal HTML document that embeds metadata required for downstream processing
        var metaObj = {
          id: String(id),
          title: String(title || ""),
          createdAt: toISOString(createdAt),
          updatedAt: toISOString(updatedAt),
          folder: String(folder || ""),
        };
        var metaJson;
        try {
          metaJson = JSON.stringify(metaObj);
        } catch (_) {
          metaJson = "{}";
        }
        var titleEsc = String(title || "")
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;");
        var doc =
          "<!doctype html>\n" +
          "<html>\n" +
          "<head>\n" +
          '<meta charset="utf-8">\n' +
          "<title>" +
          titleEsc +
          "</title>\n" +
          '<script type="application/json" id="visual-notes-meta">' +
          metaJson +
          "</script>\n" +
          "</head>\n" +
          "<body>" +
          String(htmlStr || "") +
          "</body>\n" +
          "</html>\n";
        var data = $(doc).dataUsingEncoding($.NSUTF8StringEncoding);
        if (data) data.writeToFileAtomically($(fullPath), true);
        return fullPath;
      } catch (e) {
        try {
          logErr("[JXA] Failed to write HTML file: " + String(e));
        } catch (_) {}
        return null;
      }
    }

    try {
      var limitStr = getEnvString("LIMIT");
      if (limitStr) {
        var parsed = parseInt(String(limitStr), 10);
        if (!isNaN(parsed) && parsed > 0) limit = parsed;
      }
      var outDirStr = getEnvString("HTML_OUT_DIR");
      if (outDirStr && outDirStr.length > 0) {
        htmlOutDir = outDirStr;
        ensureDir(htmlOutDir);
      }
      var inlineStr = getEnvString("INLINE_HTML");
      if (
        inlineStr &&
        (inlineStr === "1" || String(inlineStr).toLowerCase() === "true")
      )
        inlineHtml = true;
      var sinceStr = getEnvString("SINCE_EPOCH_SEC");
      if (sinceStr) {
        var sParsed = parseInt(String(sinceStr), 10);
        if (!isNaN(sParsed) && sParsed > 0) sinceEpochSec = sParsed;
      }
      var skipPath = getEnvString("SKIP_INDEX_PATH");
      if (skipPath && skipPath.length > 0) {
        try {
          var data = $.NSString.stringWithContentsOfFileEncodingError(
            $(skipPath),
            $.NSUTF8StringEncoding,
            null
          );
          if (data) {
            var jsonStr = ObjC.unwrap(data);
            try {
              var parsed = JSON.parse(String(jsonStr));
              if (parsed && typeof parsed === "object") skipIndex = parsed;
            } catch (eJson) {}
          }
        } catch (eRead) {}
      }
    } catch (_) {}
    logErr("[JXA] LIMIT=" + (limit === null ? "none" : String(limit)));
    if (htmlOutDir) logErr("[JXA] HTML_OUT_DIR=" + String(htmlOutDir));
    logErr("[JXA] INLINE_HTML=" + (inlineHtml ? "yes" : "no"));
    if (sinceEpochSec !== null)
      logErr("[JXA] SINCE_EPOCH_SEC=" + String(sinceEpochSec));
    var skipCount = 0;
    try {
      skipCount = Object.keys(skipIndex).length;
    } catch (_) {}
    if (skipCount > 0) logErr("[JXA] SKIP_INDEX entries=" + String(skipCount));

    // Return an object with reason/details if the note should be skipped, else null
    function getSkipInfo(id, modifiedDate) {
      try {
        var modMs = new Date(modifiedDate).getTime();
        if (sinceEpochSec !== null) {
          var thresholdMs = sinceEpochSec * 1000;
          if (!isNaN(modMs) && modMs < thresholdMs) {
            return {
              reason: "before-since-threshold",
              sinceEpochSec: sinceEpochSec,
            };
          }
        }
        if (skipIndex && id && typeof skipIndex[id] === "string") {
          var prevIso = skipIndex[id];
          var prevMs = new Date(prevIso).getTime();
          if (!isNaN(prevMs) && !isNaN(modMs) && modMs <= prevMs) {
            return {
              reason: "not-changed-since-prev",
              prevUpdatedAt: prevIso,
            };
          }
        }
      } catch (_) {}
      return null;
    }

    // Fast path: try application-level notes() first and stop at LIMIT
    var tFastStart = nowMs();
    logErr("[JXA] Fast path: app.notes() enumeration start");
    try {
      var appNotes = app.notes();
      logErr("[JXA] app.notes() obtained; iterating...");
      for (var i = 0; limit === null || wrote < limit; i++) {
        var note;
        try {
          note = appNotes[i];
        } catch (eIdx) {
          break;
        }
        if (!note) break;
        var tNote = nowMs();
        var created = note.creationDate();
        var modified = note.modificationDate
          ? note.modificationDate()
          : created;
        var title = note.name();
        var id = note.id();
        var skipInfo = getSkipInfo(String(id), modified);
        if (skipInfo) {
          skipped++;
          try {
            var logObj = {
              id: String(id),
              title: String(title || ""),
              updatedAt: toISOString(modified),
              reason: String(skipInfo.reason || "unknown"),
            };
            if (skipInfo.sinceEpochSec !== undefined)
              logObj.sinceEpochSec = skipInfo.sinceEpochSec;
            if (skipInfo.prevUpdatedAt)
              logObj.prevUpdatedAt = String(skipInfo.prevUpdatedAt);
            logErr("[JXA][skip] " + JSON.stringify(logObj));
          } catch (_) {}
          continue;
        }
        var tBody = nowMs();
        var body = note.body();
        var bodyMs = nowMs() - tBody;
        var htmlStr = String(body || "");
        var outPath = htmlOutDir
          ? writeHtmlFile(
              htmlOutDir,
              wrote + 1,
              title,
              id,
              created,
              modified,
              "",
              htmlStr
            )
          : null;
        results.push({
          id: String(id),
          title: String(title || ""),
          createdAt: toISOString(created),
          updatedAt: toISOString(modified),
          folder: "",
          html: inlineHtml ? htmlStr : "",
          filePath: outPath,
        });
        wrote++;
        var totalMs = nowMs() - tNote;
        if (wrote <= 5 || wrote % 50 === 0) {
          logErr(
            "[JXA] app.notes() note #" +
              wrote +
              " timings: body=" +
              bodyMs +
              "ms total=" +
              totalMs +
              "ms"
          );
        }
      }
    } catch (_) {}
    logErr(
      "[JXA] Fast path complete: wrote=" +
        wrote +
        " in " +
        (nowMs() - tFastStart) +
        "ms"
    );

    // Fallback paths removed intentionally to avoid duplicates and slowness.

    logErr(
      "[JXA] Done. wrote=" +
        wrote +
        " skipped=" +
        skipped +
        " totalTime=" +
        (nowMs() - tStart) +
        "ms"
    );
    try {
      return JSON.stringify({
        notes: results,
        wrote: wrote,
        skipped: skipped,
        outDir: htmlOutDir,
        inline: inlineHtml,
      });
    } catch (_) {
      return JSON.stringify(results);
    }
  } catch (e) {
    try {
      logErr("[JXA] Fatal error: " + String(e));
    } catch (_) {}
    try {
      if (typeof results !== "undefined") return JSON.stringify(results);
    } catch (_) {}
    throw e;
  }
}

main();
