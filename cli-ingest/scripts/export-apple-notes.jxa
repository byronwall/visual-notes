// JXA script: run with `osascript -l JavaScript export-apple-notes.jxa`
// Exports Apple Notes as a single JSON array with inline HTML for each note.

function toISOString(date) {
  // JXA Date object behaves as JS Date
  return new Date(date).toISOString();
}

// Write diagnostics to stderr so stdout stays clean JSON
function logErr(msg) {
  try {
    var str = String(msg) + "\n";
    var data = $(str).dataUsingEncoding($.NSUTF8StringEncoding);
    $.NSFileHandle.fileHandleWithStandardError.writeData(data);
  } catch (_) {}
}

function nowMs() {
  return Date.now();
}

function main() {
  try {
    var tStart = nowMs();
    var app = Application("Notes");
    app.includeStandardAdditions = true;
    try {
      app.activate();
    } catch (_) {}
    logErr("[JXA] Started Notes export");

    var results = [];
    var wrote = 0;
    var skipped = 0;
    var limit = null;
    var htmlOutDir = null;
    var inlineHtml = false;
    var knownIds = {};
    var knownCount = 0;

    function getEnvString(key) {
      try {
        var env = $.NSProcessInfo.processInfo.environment;
        var obj = env.objectForKey(String(key));
        if (obj) {
          try {
            return ObjC.unwrap(obj);
          } catch (_) {
            return String(obj);
          }
        }
      } catch (_) {}
      try {
        ObjC.import("stdlib");
        var cstr = $.getenv(String(key));
        if (cstr) return ObjC.unwrap(cstr);
      } catch (_) {}
      return null;
    }

    function sanitizeFilename(title, id) {
      try {
        var base = String(title || "")
          .toLowerCase()
          .replace(/\s+/g, "-")
          .replace(/[^a-z0-9\-_.]/g, "-")
          .replace(/-+/g, "-")
          .replace(/^[-.]+|[-.]+$/g, "");
        var fallback = String(id || "").slice(0, 12) || "note";
        var trimmed = base.slice(0, 64) || fallback;
        return trimmed;
      } catch (_) {
        return "note";
      }
    }

    function sanitizeCoreDataId(id) {
      try {
        var s = String(id || "")
          .toLowerCase()
          .replace(/[^a-z0-9\-_]/g, "-")
          .replace(/-+/g, "-")
          .replace(/^[-.]+|[-.]+$/g, "");
        return s.slice(0, 64) || "id";
      } catch (_) {
        return "id";
      }
    }

    function formatTimestampUTC(dateLike) {
      try {
        var d = new Date(dateLike);
        var yyyy = String(d.getUTCFullYear());
        var mm = String(d.getUTCMonth() + 1).padStart(2, "0");
        var dd = String(d.getUTCDate()).padStart(2, "0");
        var hh = String(d.getUTCHours()).padStart(2, "0");
        var mi = String(d.getUTCMinutes()).padStart(2, "0");
        var ss = String(d.getUTCSeconds()).padStart(2, "0");
        return yyyy + mm + dd + "T" + hh + mi + ss + "Z";
      } catch (_) {
        return "unknown";
      }
    }

    function ensureDir(dirPath) {
      try {
        var fm = $.NSFileManager.defaultManager;
        var isDir = Ref();
        var nsPath = $(dirPath);
        if (!(fm.fileExistsAtPathIsDirectory(nsPath, isDir) && isDir[0])) {
          fm.createDirectoryAtPathWithIntermediateDirectoriesAttributesError(
            nsPath,
            true,
            null,
            null
          );
        }
      } catch (_) {}
    }

    function writeHtmlFile(
      dirPath,
      idx,
      title,
      id,
      createdAt,
      updatedAt,
      folder,
      htmlStr
    ) {
      try {
        var base = sanitizeFilename(title, id);
        var idPart = sanitizeCoreDataId(id);
        var ts = formatTimestampUTC(updatedAt);
        var fileName = idPart + "-" + ts + "-" + base + ".html";
        var fullPath = dirPath + "/" + fileName;
        // Build a minimal HTML document that embeds metadata required for downstream processing
        var metaObj = {
          id: String(id),
          title: String(title || ""),
          createdAt: toISOString(createdAt),
          updatedAt: toISOString(updatedAt),
          folder: String(folder || ""),
        };
        var metaJson;
        try {
          metaJson = JSON.stringify(metaObj);
        } catch (_) {
          metaJson = "{}";
        }
        var titleEsc = String(title || "")
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;");
        var doc =
          "<!doctype html>\n" +
          "<html>\n" +
          "<head>\n" +
          '<meta charset="utf-8">\n' +
          "<title>" +
          titleEsc +
          "</title>\n" +
          '<script type="application/json" id="visual-notes-meta">' +
          metaJson +
          "</script>\n" +
          "</head>\n" +
          "<body>" +
          String(htmlStr || "") +
          "</body>\n" +
          "</html>\n";
        var data = $(doc).dataUsingEncoding($.NSUTF8StringEncoding);
        if (data) data.writeToFileAtomically($(fullPath), true);
        return fullPath;
      } catch (e) {
        try {
          logErr("[JXA] Failed to write HTML file: " + String(e));
        } catch (_) {}
        return null;
      }
    }

    try {
      var limitStr = getEnvString("LIMIT");
      if (limitStr) {
        var parsed = parseInt(String(limitStr), 10);
        if (!isNaN(parsed) && parsed > 0) limit = parsed;
      }
      var outDirStr = getEnvString("HTML_OUT_DIR");
      if (outDirStr && outDirStr.length > 0) {
        htmlOutDir = outDirStr;
        ensureDir(htmlOutDir);
      }
      var inlineStr = getEnvString("INLINE_HTML");
      if (
        inlineStr &&
        (inlineStr === "1" || String(inlineStr).toLowerCase() === "true")
      )
        inlineHtml = true;
      var knownPath = getEnvString("KNOWN_IDS_PATH");
      if (knownPath && knownPath.length > 0) {
        try {
          var data2 = $.NSString.stringWithContentsOfFileEncodingError(
            $(knownPath),
            $.NSUTF8StringEncoding,
            null
          );
          if (data2) {
            var jsonStr2 = ObjC.unwrap(data2);
            try {
              var parsed2 = JSON.parse(String(jsonStr2));
              var arr = null;
              if (parsed2 && parsed2.ids && parsed2.ids.map) {
                arr = parsed2.ids.map(String);
              } else if (
                parsed2 &&
                parsed2.map &&
                parsed2.length !== undefined
              ) {
                arr = parsed2.map(String);
              }
              if (arr) {
                for (var ii = 0; ii < arr.length; ii++) knownIds[arr[ii]] = 1;
                knownCount = arr.length;
              }
              if (
                parsed2 &&
                parsed2.count &&
                !isNaN(parseInt(String(parsed2.count), 10))
              ) {
                knownCount = parseInt(String(parsed2.count), 10);
              }
            } catch (eJson2) {}
          }
        } catch (eRead2) {}
      }
      var knownCountStr = getEnvString("KNOWN_COUNT");
      if (knownCountStr) {
        var kcParsed = parseInt(String(knownCountStr), 10);
        if (!isNaN(kcParsed) && kcParsed >= 0) knownCount = kcParsed;
      }
    } catch (_) {}
    logErr("[JXA] LIMIT=" + (limit === null ? "none" : String(limit)));
    if (htmlOutDir) logErr("[JXA] HTML_OUT_DIR=" + String(htmlOutDir));
    logErr("[JXA] INLINE_HTML=" + (inlineHtml ? "yes" : "no"));
    var knownSize = 0;
    try {
      knownSize = Object.keys(knownIds).length;
    } catch (_) {}
    if (knownSize > 0) logErr("[JXA] KNOWN_IDS entries=" + String(knownSize));
    if (knownCount) logErr("[JXA] KNOWN_COUNT=" + String(knownCount));

    // Index-based traversal using server inventory
    var tStartWalk = nowMs();
    var appNotes = app.notes();
    var total = 0;
    try {
      total = appNotes.length;
    } catch (_) {
      total = 0;
    }
    logErr("[JXA] notes() length=" + String(total));

    function exportNoteAtIndex(idx) {
      logErr("[JXA] Exporting note at index " + idx);
      try {
        var note = appNotes[idx];
        if (!note) return false;
        var created = note.creationDate();
        var modified = note.modificationDate
          ? note.modificationDate()
          : created;
        var title = note.name();
        var id = note.id();
        // Skip if already known
        if (id && knownIds[String(id)]) {
          skipped++;
          return false;
        }
        var body = note.body();
        var htmlStr = String(body || "");
        var outPath = htmlOutDir
          ? writeHtmlFile(
              htmlOutDir,
              wrote + 1,
              title,
              id,
              created,
              modified,
              "",
              htmlStr
            )
          : null;
        results.push({
          id: String(id),
          title: String(title || ""),
          createdAt: toISOString(created),
          updatedAt: toISOString(modified),
          folder: "",
          html: inlineHtml ? htmlStr : "",
          filePath: outPath,
        });
        wrote++;
        return true;
      } catch (_) {
        logErr("[JXA] Error exporting note at index " + idx);
        return false;
      }
    }

    // Phase 1: from start until we hit a known id
    var idx = 0;
    var firstKnownIdx = -1;
    for (; (limit === null || wrote < limit) && idx < total; idx++) {
      var idTry = null;
      try {
        idTry = appNotes[idx].id();
      } catch (_) {
        logErr("Error getting id for note at index " + idx);
        break;
      }
      if (idTry && knownIds[String(idTry)]) {
        firstKnownIdx = idx;
        break;
      }
      exportNoteAtIndex(idx);
    }

    if (limit === null || wrote < limit) {
      // Phase 2: jump forward by knownCount
      var jumpTo =
        firstKnownIdx >= 0 ? firstKnownIdx + knownCount : idx + knownCount;
      if (jumpTo >= total) jumpTo = total - 1;
      if (jumpTo < 0) jumpTo = 0;

      // Phase 3: walk backward until we find a known id
      var back = jumpTo;
      var boundary = -1;
      while (back >= 0) {
        var idBack = null;
        try {
          idBack = appNotes[back].id();
        } catch (_) {
          break;
        }
        if (idBack && knownIds[String(idBack)]) {
          boundary = back;
          break;
        }
        back--;
      }
      if (boundary < 0) boundary = -1; // start from 0 if none found

      // Phase 4: go forward from boundary+1 until limit or end
      var forward = boundary + 1;
      while ((limit === null || wrote < limit) && forward < total) {
        exportNoteAtIndex(forward);
        forward++;
      }
    }
    logErr(
      "[JXA] Index walk complete: wrote=" +
        wrote +
        " skipped=" +
        skipped +
        " in " +
        (nowMs() - tStartWalk) +
        "ms"
    );

    logErr(
      "[JXA] Done. wrote=" +
        wrote +
        " skipped=" +
        skipped +
        " totalTime=" +
        (nowMs() - tStart) +
        "ms"
    );
    try {
      return JSON.stringify({
        notes: results,
        wrote: wrote,
        skipped: skipped,
        outDir: htmlOutDir,
        inline: inlineHtml,
      });
    } catch (_) {
      return JSON.stringify(results);
    }
  } catch (e) {
    try {
      logErr("[JXA] Fatal error: " + String(e));
    } catch (_) {}
    try {
      if (typeof results !== "undefined") return JSON.stringify(results);
    } catch (_) {}
    throw e;
  }
}

main();
