# AGENTS.md - Visual Notes + Base Component System

This file combines the repo-level agent instructions with the SolidJS code
guidelines from comp_refs.

## Visual Notes Agent Instructions

## Working in this repo

### Quick rules

- Generated output
  - `app/styled-system/` is generated by Panda; do not edit by hand.
  - If styles/types look wrong, run `pnpm prepare` (or `pnpm dev`, which runs it first).
- Data loading (SolidStart)
  - Reads: `query()` + `createAsync()`
  - Writes: server actions
  - Avoid `fetch()` in UI components for app data, and avoid adding React Query/SWR/etc.
- Component size & composition
  - Prefer small components; keep files ~200 lines when feasible and split early.
  - Split into separate files for subcomponents/hooks/helpers/types when possible.
  - Avoid excessive prop drilling; use shared context or a small store when needed.
  - Keep styles next to their users; do not extract CSS-in-JSS unless reused.
- UI + styling
  - Prefer `~/components/ui/*` wrappers over direct Ark UI usage in routes.
  - Prefer Panda (`css`, `styled-system/jsx`, `recipes`) over ad-hoc CSS.
  - Token usage only; avoid raw hex codes or arbitrary spacing unless a token is missing.
- Routes are routes
  - Do not create reusable UI under `app/src/routes/`.
  - Keep route modules focused on routing + data + page composition; move reusable UI to `app/src/components/` (or `~/components/*`).

## Skills

A skill is a set of local instructions to follow that is stored in a
`SKILL.md` file. Below is the list of skills that can be used. Each entry
includes a name, description, and file path so you can open the source for
full instructions when using a specific skill.

### Available skills

- skill-creator: Guide for creating effective skills. This skill should be
  used when users want to create a new skill (or update an existing skill)
  that extends Codex's capabilities with specialized knowledge, workflows,
  or tool integrations.
  (file: /Users/byronwall/.codex/skills/.system/skill-creator/SKILL.md)
- skill-installer: Install Codex skills into $CODEX_HOME/skills from a
  curated list or a GitHub repo path. Use when a user asks to list
  installable skills, install a curated skill, or install a skill from
  another repo (including private repos).
  (file: /Users/byronwall/.codex/skills/.system/skill-installer/SKILL.md)

### How to use skills

- Discovery: The list above is the skills available in this session (name +
  description + file path). Skill bodies live on disk at the listed paths.
- Trigger rules: If the user names a skill (with $SkillName or plain text)
  OR the task clearly matches a skill's description shown above, you must use
  that skill for that turn. Multiple mentions mean use them all. Do not carry
  skills across turns unless re-mentioned.
- Missing/blocked: If a named skill isn't in the list or the path can't be
  read, say so briefly and continue with the best fallback.
- How to use a skill (progressive disclosure):
  1. After deciding to use a skill, open its SKILL.md. Read only enough to
     follow the workflow.
  2. If SKILL.md points to extra folders such as references/, load only the
     specific files needed for the request; don't bulk-load everything.
  3. If scripts/ exist, prefer running or patching them instead of retyping
     large code blocks.
  4. If assets/ or templates exist, reuse them instead of recreating from
     scratch.
- Coordination and sequencing:
  - If multiple skills apply, choose the minimal set that covers the request
    and state the order you'll use them.
  - Announce which skill(s) you're using and why (one short line). If you
    skip an obvious skill, say why.
- Context hygiene:
  - Keep context small: summarize long sections instead of pasting them; only
    load extra files when needed.
  - Avoid deep reference-chasing: prefer opening only files directly linked
    from SKILL.md unless you're blocked.
  - When variants exist (frameworks, providers, domains), pick only the
    relevant reference file(s) and note that choice.
- Safety and fallback: If a skill can't be applied cleanly (missing files,
  unclear instructions), state the issue, pick the next-best approach, and
  continue.

## SolidJS Code Guidelines (from comp_refs)

This repo prioritizes predictable SolidJS reactivity, clear TypeScript types,
and maintainable component boundaries.

If a guideline conflicts with existing code patterns, follow this doc for new
code and refactors unless explicitly told otherwise.

### Goals

- Keep components easy to reason about.
  - Prefer local clarity over clever abstractions.
  - Prefer explicit control-flow components (Show, Switch/Match, Suspense)
    over JS shortcuts.
- Keep files small and scannable.
  - Aim for < 200 LOC per file.
  - Prefer 1 component per file, unless multiple components are tiny and
    tightly related.

### General UI patterns

- Highlight matches in search results.

  - Users should be able to visually scan why an item matched without rereading the whole row/card.
  - Highlight both the main text and secondary fields that participate in matching (title/body/tags/etc.) and keep the highlight styling consistent across the app.
  - Prefer safe text segmentation (rendering plain text with highlighted spans) over injecting HTML.
  - Prefer the shared helper `renderHighlighted` from `app/src/features/docs-index/utils/highlight.tsx` for search-result highlighting so styling stays consistent across the app.

- Icons as buttons

  - If an icon is meant to behave like a button (clickable action), always wrap it with `IconButton` (don’t attach click handlers directly to the icon).

- Maintain a stable (often fixed) height for dynamic lists and streaming/async content.
  - Avoid layout shift when new items arrive, results load, or panels expand; reserve space up-front with a fixed height or a min-height + skeleton/loading row strategy.
  - Prefer scrollable regions (`overflow: auto`) for results panes so the surrounding layout stays anchored and the user's cursor/scroll position doesn't jump.
  - When inserting items at the top (e.g. newest-first), consider scroll anchoring so content doesn't “push down” unexpectedly. If that’s non-trivial, add `TODO:EDGE_CASE, scroll anchoring when prepending items`.
  - Exceptions (use judgment; default is still “avoid shift”):
    - When the element is effectively the only thing on the page (no adjacent content to disturb), a natural expanding height is often fine.
    - When there’s no surrounding modal/dialog/panel layout that would be pushed/reflowed by the content (i.e. expansion won’t cause secondary UI to jump).
    - When it’s known that the shift is expected and non-jarring (e.g. a single results page that replaces a loading state in-place), prefer simplicity over over-constraining the layout.

- Hover overlays in scrollable sidebars/lists (HoverCard/Tooltip/Popover).
  - Use `Trigger` with `asChild` render function and pass a native DOM element (`a`/`button`) so the floating layer has a stable anchor ref.
  - In scrolled/sticky layouts, prefer explicit positioning options (for example `placement: "right-start"` plus `strategy: "fixed"`) to avoid top-of-page fallback flashes.
  - Avoid mutating reactive state in `onOpenChange` that changes the hovered row tree while positioning is being computed.
  - If hover content needs extra data, prefetch lightweight preview data for the visible list instead of fetching on-hover; this keeps anchor measurement stable and prevents flicker.
  - Use shared text-preview helpers from `app/src/features/docs-index/utils/doc-preview.ts` (`clipDocTitle`, `buildDocPreviewText`, `countMetaKeys`, `normalizePreviewText`) instead of duplicating markdown/html strip logic in UI components.
  - Reuse `DocHoverPreviewLink` at `app/src/components/docs/DocHoverPreviewLink.tsx` for note/story hover previews instead of rebuilding HoverCard markup per list.
  - Reuse `useDocPreviewMap` at `app/src/features/docs-index/hooks/useDocPreviewMap.ts` to prefetch visible note details for hover cards.

### UI composition (ParkUI simplification)

- Prefer `SimplePopover`, `SimpleDialog`, `SimpleModal`, and `SimpleSelect`
  wrappers over raw ParkUI/Ark UI composition when they meet the need.
- Use `skipPortal` on these wrappers when you must render inline; default is
  to render in a Portal.
- In ParkUI components, the `asChild` prop is a render function, not a
  boolean.
- When creating derived comps, be sure to import the ParkUI things with their ORIGINAL names. If not, the CSS breaks.
  - Good: import \* as Popover from "./popover";
  - Bad: import { Root } from "./popover";
- When creating a derived component, add the name to the recipe in the `jsx` key.
  - Good: jsx: ["Popover", "MyDerivedComponent"],
  - Bad: jsx: ["MyDerivedComponent"],
- When importing ParkUI components, use a barrel import if there are multiple things to import.
  - Good: import \* as Popover from "./popover";
  - Bad: import { Root, Anchor, Positioner, Content } from "./popover";
- Avoid nested popovers for a single interaction flow unless there is a strong UX reason.
  - Prefer one overlay layer and render extra controls as inline sections inside that layer.
  - If nesting is intentional, add a short comment explaining why.

### Tailwind → Panda conversion (from park-ui-migration)

- No Tailwind utility strings in migrated components; use Panda props and
  `styled-system/jsx` layout primitives (`Box`, `Stack`, `HStack`, `Flex`,
  `Container`, `Spacer`).
- Replace native controls/ad-hoc elements with `~/components/ui/*` (e.g.
  `Button`, `Link`, `Input`, `Checkbox`, `Select`, `Drawer`).
- Convert leftover utility classes to Panda props and prefer semantic tokens
  (`bg="bg.default"`, `borderColor="border"`, `color="fg.muted"`).
- Use `HStack` for horizontal layout and remember its prop is `alignItems`
  (not `align`).
- For Select: build a `createListCollection`, pass it to `Select.Root`, and
  treat `value` as `string[]` even for single-select.
- Keep Solid discipline during migration: `Show` over `&&`, `Suspense` for
  resources, avoid prop destructuring.

### File structure and organization

- One component per file by default.
  - Exception: a small set of private helper components (icons, tiny
    subcomponents) that are only used by the parent component.
- Types live with their consumer.
  - Props types MUST be defined in the same file as the component.
  - General-purpose/shared types belong in a common types module.
- Helpers
  - If a helper is reusable, move it to a common place (src/utils/_,
    src/lib/_, etc.).
  - Component-specific helpers can stay local, but if they grow or become
    shared, promote them.

### Imports and exports

- Imports occur at the top of the file.
  - No lazy/deferred imports.
  - No inline imports in functions.
- Prefer named exports over default exports.
- Type imports:
  - Good: import { type Foo } from "./foo"
  - Avoid: typeof import("./foo").Foo

### TypeScript rules

- Avoid any.
  - If any is unavoidable, add a comment explaining why.
- Avoid as any to silence lint/type issues.
  - If you must, mark it clearly:
    - TODO:AS_ANY, <reason>
- Avoid creating "mirror types" that duplicate an object's structure.
  - Prefer deriving types from existing values/returns when possible.
  - If blocked by tooling or an inference issue:
    - TODO:TYPE_MIRROR, <reason>
- Prefer type over interface.
  - Use intersection composition where needed:
    - type Props = BaseProps & { extra: string }

### Debugging

- Use console.log for debugging.
- For large code changes/chunks, add a couple logs to clarify:
  - entry/exit
  - important branch decisions
  - key data shape/ids
- Do not wrap console.log in try/catch.
- Remove temporary debug logs before finishing unless the user explicitly asks to keep them.

### Control flow and readability

- Prefer early returns over deeply nested conditionals.
- Prefer Solid control-flow components:
  - Use Show over && for conditional rendering.
  - Prefer Switch/Match for top-level forks when multiple branches exist.

### Conditional rendering rules

- Use Show to narrow types safely.
  - Prefer function children when you want narrowed typing.

Good:
<Show when={user()}>{(u) => <UserCard user={u} />}</Show>

Avoid:
{ user() && <UserCard user={user()!} />; }

### SolidJS reactivity fundamentals

Signals vs stores

- Single independent value: createSignal
- Multiple related values: createStore
- If state fields conceptually belong together, make a store.

Derived values: inline thunks vs createMemo

- Inline thunks are fine for most derived values:
  - const label = () => props.title ?? "Untitled"
- Only use createMemo when there's likely a performance hit:
  - sorting, filtering, heavy mapping, expensive formatting, large lists

Effects

- Prefer createEffect. Do not use createComputed.
- Effects should be for side effects, not for pure derivations.

Batching updates

- Use batch(() => { ... }) when updating multiple signals or multiple store
  paths in a tight sequence.
  - If multiple fields represent one user-visible value, update them atomically.
  - Avoid intermediate transient states that can fire effects/callbacks with invalid values.

Prop sync (external props ↔ local draft state)

- For local draft state initialized from props, sync only when the incoming prop actually changes.
- Compare against a previous incoming-prop snapshot (non-reactive local variable), not mutable draft state.
- In parent/child feedback loops (`value` + `onChange`), guard no-op updates to avoid ping-pong resets.

### Props handling

- Do not destructure props (neither in parameters nor inside the body).
  - Solid props are reactive; destructuring breaks reactivity.
- Use splitProps when you need "local names".
- mergeProps is allowed.

### Client ↔ server communication (SolidStart)

Use SolidStart’s SSR-friendly data APIs:

- Reads: `query()` (server) + `createAsync()` (client)
- Writes: server actions
- Avoid raw `fetch(...)` inside UI components for app data

Example (read via `query`):

```ts
import { query, createAsync } from "@solidjs/router";

// server-side fetcher; args must be JSON-serializable
export const getThing = query(async (id: string) => {
  "use server";
  // ... load data (db/service/etc) ...
  return { id };
}, "thing");

// client usage (route/component)
const thing = createAsync(() => getThing("123"));
```

Example (write via server action):

```ts
import { action } from "@solidjs/router";

export const saveThing = action(
  async (payload: { id: string; name: string }) => {
    "use server";
    // ... write to db/service ...
    return { ok: true };
  },
  "save-thing"
);
```

### Event handlers and callbacks

- Inline handlers are OK if short (<= 3 lines).
- If longer than 3 lines, pull into a named function in parent scope.
- Avoid preventDefault and stopPropagation unless there is a strong reason.

### Lists: <For> rules

- Prefer <For> over .map() in JSX.
- No need to set keyed by default.
- When creating render functions inside a <For>, all variables must be
  reactive functions.

### Resources: createResource + Suspense

- If createResource is involved, ALWAYS use Suspense with a fallback.
- Avoid using Show as the primary loading gate for resources.
- Prefer handling empty states inside the resolved UI rather than branching around the resource.

### Error boundaries

- Every major page/feature "island" MUST be wrapped in an <ErrorBoundary>.
- Keep fallbacks user-friendly; logging in the fallback is OK.

### Global state and Context API

- Avoid prop drilling beyond 3 levels.
- Prefer using an exported Provider from a module.
- Context consumers MUST go through a useX() helper that throws if used
  outside the Provider.
- Prefer stores for related context state. Keep Provider logic small; move non-UI logic to a shared module if it grows.

### DOM refs and component communication

- For DOM refs:
  - Use let myRef; and ref={myRef}.
  - Avoid document.getElementById entirely.

### Mounting, cleanup, and subscriptions

- When pairing onMount with onCleanup, place onCleanup inside the onMount
  callback.

### Components and composition

- Avoid IIFEs for Solid components.
- SVG icons: put inline SVG into its own component with a good name.

### Error handling

- Avoid wrapping code in try/catch unless clearly justified or requested.

### Prisma rules (server-side)

- Only modify the Prisma schema.
- Always generate migrations via CLI.
- Never manually author a migration file.
- Follow the repo’s standard scripts/commands for generating and applying migrations.

### Thinking and planning conventions

- When designing new components, consider key edge cases and handle them if
  simple. If handling is non-trivial, add:
  - TODO:EDGE_CASE, <describe the case>

### TODO tags (standardized)

- TODO:AS_ANY, <reason>
- TODO:TYPE_MIRROR, <reason>
- TODO:EDGE_CASE, <reason>

### Testing and verification

- Run pnpm type-check to verify TypeScript types after making changes.
- Do not run pnpm build for routine change verification; type-check is sufficient.
- There are no unit tests currently; verification is done via successful
  type check and manual testing.

### Quick checklist (before you finish)

- File is < 200 LOC (or intentionally justified)
- No props destructuring; used splitProps if needed
- Used createStore for related state
- Derived values use thunks; createMemo only when it matters
- Used batch when updating multiple signals/store paths together
- Show instead of &&
- Switch/Match for multi-branch top-level forks
- <For> render locals are reactive functions
- createResource is gated by Suspense fallback
- Major feature islands wrapped in <ErrorBoundary>
- Context uses exported Provider + exported useX() hook
- Refs via let ref + ref={ref}; no document.getElementById
- Cleanup paired with mount is inside onMount
- No any without a comment; no as any without TODO:AS_ANY
- Named exports; imports at top; no typeof import(...)
- Large changes include a few console.log breadcrumbs
